#!/usr/bin/env python

# nxos-bootstrap

import sys
import os
import json
import argparse
import subprocess
import logging
import time
import socket
import requests
import yaml

import aeon.nxos as nxos
import aeon.nxos.exceptions as NxExc
from aeon.exceptions import ProbeError, UnauthorizedError

_PROGNAME = 'nxos-bootstrap'
_PROGVER = '0.0.1'

_API_PORT = 5000

# ##### -----------------------------------------------------------------------
# #####
# #####                           Command Line Arguments
# #####
# ##### -----------------------------------------------------------------------

psr = argparse.ArgumentParser(
    prog=_PROGNAME,
    description="Aeon ZTP bootstrapper for NXOS",
    add_help=True)

psr.add_argument(
    '--target', required=True,
    help='hostname or ip_addr of target device')

psr.add_argument(
    '--topdir', required=True,
    help='toplevel directory aztp installation files')

psr.add_argument(
    '--logfile',
    help='name of log file')

psr.add_argument(
    '--reload-delay',
    dest='reload_delay',
    type=int, default=10*60,
    help="about of time/s to try to reconnect to device after reload")

psr.add_argument(
    '--init-delay',
    dest='init_delay',
    type=int, default=60,
    help="amount of time/s to wait before starting the bootstrap process")

# ##### -------------------------
# ##### authentication
# ##### -------------------------

group = psr.add_argument_group('authentication')

group.add_argument(
    '-U', dest='user_var',
    required=True,
    help='Username environment variable')

group.add_argument(
    '-P', dest='passwd_var',
    required=True,
    help='Passwd environment variable')

g_cli_args = psr.parse_args()
g_log = logging.getLogger(name=_PROGNAME)
g_self_server = None


def setup_logging():
    g_log.setLevel(logging.INFO)
    fh = logging.FileHandler(g_cli_args.logfile)
    fmt = logging.Formatter(
        '%(asctime)s:%(levelname)s:{target}:%(message)s'
        .format(target=g_cli_args.target))
    fh.setFormatter(fmt)
    g_log.addHandler(fh)

if g_cli_args.logfile:
    setup_logging()


# ##### -----------------------------------------------------------------------
# #####
# #####                           Utility Functions
# #####
# ##### -----------------------------------------------------------------------

def exit_results(results, exit_error=None, dev=None):
    if results['ok']:
        post_device_status(dev=dev, state='DONE', message='bootstrap completed OK')
        sys.exit(0)
    else:
        post_device_status(dev=dev, state='FAILED', message=results['message'])
        sys.exit(exit_error or 1)


def get_my_ipaddr(dst):
    dst_s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    dst_s.connect((dst, 0))
    return dst_s.getsockname()[0]


def wait_for_device(countdown, poll_delay):
    target = g_cli_args.target
    user = os.getenv(g_cli_args.user_var)
    passwd = os.getenv(g_cli_args.passwd_var)

    dev = None

    # first we need to wait for the device to be 'reachable' via the API.
    # we'll use the probe error to detect if it is or not

    while not dev:
        msg = 'reload-countdown at: {} seconds'.format(countdown)
        post_device_status(target=target, state='AWAIT-REBOOT', message=msg)
        g_log.info(msg)

        try:
            dev = nxos.Device(
                target, user=user, passwd=passwd, timeout=poll_delay)

        except ProbeError:
            countdown -= poll_delay
            if countdown <= 0:
                exit_results(dict(
                    ok=False,
                    error_type='login',
                    message='Failed to probe target %s within reload countdown' % target))

        except UnauthorizedError:
            exit_results(dict(
                ok=False,
                error_type='login',
                message='Unauthorized - check user/password'))

    post_device_facts(dev)

    msg = 'device reachable, waiting for System ready'
    post_device_status(dev=dev, state='AWAIT-SYSTEM-READY', message=msg)
    g_log.info(msg)

    while countdown >= 0:
        msg = 'ready-countdown at: {} seconds'.format(countdown)
        post_device_status(dev=dev, message=msg)
        g_log.info(msg)

        try:
            dev.api.exec_opcmd('delete volatile:system_ready', msg_type='cli_show_ascii')
            return dev
        except NxExc.CommandError:
            # means that the file does not exist yet, so wait some time
            # and try again
            time.sleep(poll_delay)
            countdown -= poll_delay

    exit_results(dict(
        ok=False,
        error_type='login',
        message='%s failed to find "System ready" within reload countdown' % target))


# ##### -----------------------------------------------------------------------
# #####
# #####                           REST API functions
# #####
# ##### -----------------------------------------------------------------------

def post_device_start(target):
    requests.post(
        url='http://%s/api/devices' % g_self_server,
        json=dict(
            ip_addr=target,
            os_name='nxos',
            state='START',
            message='bootstrap started, waiting for device access'))


def post_device_facts(dev):
    requests.post(
        url='http://%s/api/devices' % g_self_server,
        json=dict(
            ip_addr=dev.target,
            serial_number=dev.facts['serial_number'],
            hw_model=dev.facts['hw_model'],
            os_version=dev.facts['os_version'],
            os_name='nxos',
            state='FACTS-GATHERED',
            message='facts gathered, proceeding'))


def post_device_status(dev=None, target=None, message=None, state=None):
    requests.put(
        url='http://%s/api/devices/status' % g_self_server,
        json=dict(
            os_name='nxos',
            ip_addr=target or dev.target,
            state=state, message=message))


# ##### -----------------------------------------------------------------------
# #####
# #####                           General config process
# #####
# ##### -----------------------------------------------------------------------

def do_push_config1(dev):
    topdir = g_cli_args.topdir
    config_dir = os.path.join(topdir, 'etc', 'configs', 'nxos')
    all_fpath = os.path.join(config_dir, 'all.conf')
    model_fpath = os.path.join(config_dir, dev.facts['hw_model'] + '.conf')
    changed = False

    post_device_status(
        dev=dev, state='CONFIG',
        message='applying general config from %s' % config_dir)

    try:
        if os.path.isfile(all_fpath):
            g_log.info('reading from: {}'.format(all_fpath))
            conf = open(all_fpath).read()
            g_log.info('pushing all config to device')
            dev.api.exec_config(conf)
            changed = True

        if os.path.isfile(model_fpath):
            g_log.info('reading model config from: {}'.format(model_fpath))
            conf = open(model_fpath).read()
            g_log.info('pushing model config to device')
            dev.api.exec_config(conf)
            changed = True

    except NxExc.NxosException as exc:
        g_log.critical("unable to push config: {}".format(exc.message))
        exit_results(dict(
            ok=False,
            error_type='config',
            message=exc.message))

    if changed is True:
        dev.api.exec_config("copy run start")


# ##### -----------------------------------------------------------------------
# #####
# #####                           OS install process
# #####
# ##### -----------------------------------------------------------------------

def check_os_install(dev):
    profile_dir = os.path.join(g_cli_args.topdir, 'etc', 'profiles', 'default', 'nxos')
    conf_fpath = os.path.join(profile_dir, 'os-selector.cfg')

    cmd = "aztp-os-selector -m {hw_model} -o '{os_ver}' -c {config}".format(
        hw_model=dev.facts['hw_model'],
        os_ver=dev.facts['os_version'],
        config=conf_fpath)

    child = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)

    _stdout, _stderr = child.communicate()
    return json.loads(_stdout)


def do_os_install(dev, image_name):

    image_fpath = os.path.join(g_cli_args.topdir,
                               'etc', 'image-catalog',
                               image_name)

    image_data = yaml.load(open(image_fpath))
    msg = 'installing OS version {} from {} ... please be patient'.format(
        image_data['os_version'], image_data['copy_from'])

    post_device_status(dev=dev, state='OS-INSTALL', message=msg)

    cmd = "nxos-installos --target {target} --server {server} "\
          "-U {u_env} -P {p_env} --image-profile {profile}"\
          .format(
            target=dev.target, server=get_my_ipaddr(dev.target),
            u_env=g_cli_args.user_var, p_env=g_cli_args.passwd_var,
            profile=image_fpath)

    if g_cli_args.logfile:
        cmd += ' --logfile %s' % g_cli_args.logfile

    child = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
    _stdout, _stderr = child.communicate()
    return json.loads(_stdout)


def do_ensure_os_version(dev):
    os_install = check_os_install(dev)

    if not os_install['image']:
        g_log.info('no software install required')
        return dev

    g_log.info('software image install required: %s' % os_install['image'])

    got = do_os_install(dev, image_name=os_install['image'])
    if not got['ok']:
        errmsg = 'software install [{ver}] FAILED: {reason}'.format(
                 ver=os_install['image'], reason=json.dumps(got))
        g_log.critical(errmsg)
        exit_results(dict(
            ok=False,
            error_type='install',
            message=errmsg))

    g_log.info('software install OK: %s' % json.dumps(got))
    g_log.info('rebooting device ... please be patient')

    post_device_status(
        dev, state='OS-INSTALLED',
        message='OS install OK, rebooting ... please be patient')

    time.sleep(g_cli_args.init_delay)
    return wait_for_device(countdown=g_cli_args.reload_delay, poll_delay=10)


# ##### -----------------------------------------------------------------------
# #####
# #####                           'finally' script
# #####
# ##### -----------------------------------------------------------------------

def do_finalize(dev):
    profile_dir = os.path.join(g_cli_args.topdir, 'etc', 'profiles', 'default', 'nxos')

    finalizer = os.path.join(profile_dir, 'finally')
    if not os.path.isfile(finalizer):
        g_log.info('no user provided finally script')
        return 0

    cmd = '{prog}'.format(prog=finalizer)

    this_env = os.environ.copy()
    this_env.update(dict(
        AEON_LOGFILE=g_cli_args.logfile,
        AEON_TARGET=g_cli_args.target,
        SERVER=get_my_ipaddr(g_cli_args.target)))

    message = "executing 'finally' script: {cmd}".format(cmd=cmd)
    post_device_status(dev=dev, state='FINALLY', message=message)
    g_log.info(message)

    child = subprocess.Popen(
        cmd, shell=True, env=this_env,
        stdout=subprocess.PIPE, stderr=subprocess.PIPE)

    _stdout, _stderr = child.communicate()
    g_log.info("finally stdout=[{}]".format(_stdout))
    g_log.info("finally stderr=[{}]".format(_stderr))

    return child.returncode


# ##### -----------------------------------------------------------------------
# #####
# #####                           !!! MAIN !!!
# #####
# ##### -----------------------------------------------------------------------

def main():
    global g_self_server

    g_self_server = "{}:{}".format(get_my_ipaddr(g_cli_args.target), _API_PORT)

    post_device_start(g_cli_args.target)

    if not os.path.isdir(g_cli_args.topdir):
        exit_results(dict(
            ok=False,
            error_type='args',
            message='{} is not a directory'.format(g_cli_args.topdir)))

    g_log.info("starting bootstrap process in {} seconds"
               .format(g_cli_args.init_delay))

    # first wait the init_delay amount of time ... gives the device time
    # to start the shutdown process; i.e. expect this script to be kicked
    # off from the NXOS POAP process.

    time.sleep(g_cli_args.init_delay)
    dev = wait_for_device(countdown=g_cli_args.reload_delay, poll_delay=10)

    g_log.info("proceeding with bootstrap")

    do_push_config1(dev)
    dev = do_ensure_os_version(dev)
    do_finalize(dev)

    g_log.info("bootstrap process finished")
    exit_results(dict(ok=True), dev=dev)

if '__main__' == __name__:
    main()
