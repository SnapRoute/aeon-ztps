#!/usr/bin/env python

# nxos-bootstrap

import sys
import os
import json
import argparse
import subprocess
import logging
import time
import re

import aeon.nxos as nxos
import aeon.nxos.exceptions as NxExc
from aeon.exceptions import ProbeError, UnauthorizedError

_PROGNAME = 'nxos-bootstrap'
_PROGVER = '0.0.1'

# ##### -----------------------------------------------------------------------
# #####
# #####                           Command Line Arguments
# #####
# ##### -----------------------------------------------------------------------

psr = argparse.ArgumentParser(
    prog=_PROGNAME,
    description="Aeon ZTP bootstrapper for NXOS",
    add_help=True)

psr.add_argument(
    '--target', required=True,
    help='hostname or ip_addr of target device')

psr.add_argument(
    '--server', required=True,
    help='ip-addr of the server hosting the image files')

psr.add_argument(
    '--topdir', required=True,
    help='toplevel directory aztp installation files')

psr.add_argument(
    '--logfile',
    help='name of log file')

psr.add_argument(
    '--reload-delay',
    dest='reload_delay',
    default=10*60,
    help="about of time/s to try to reconnect to device after reload")

psr.add_argument(
    '--init-delay',
    dest='init_delay',
    default=60,
    help="amount of time/s to wait before starting the bootstrap process")

# ##### -------------------------
# ##### authentication
# ##### -------------------------

group = psr.add_argument_group('authentication')

group.add_argument(
    '-U', dest='user_var',
    required=True,
    help='Username environment variable')

group.add_argument(
    '-P', dest='passwd_var',
    required=True,
    help='Passwd environment variable')

g_cli_args = psr.parse_args()
g_log = logging.getLogger(name=_PROGNAME)


def setup_logging():
    g_log.setLevel(logging.INFO)
    fh = logging.FileHandler(g_cli_args.logfile)
    fmt = logging.Formatter(
        '%(asctime)s:%(levelname)s: {target}:%(message)s'
        .format(target=g_cli_args.target))
    fh.setFormatter(fmt)
    g_log.addHandler(fh)

if g_cli_args.logfile:
    setup_logging()


# ##### -----------------------------------------------------------------------
# #####
# #####                           Utility Functions
# #####
# ##### -----------------------------------------------------------------------

def exit_results(results, exit_error=None):
    json.dump(results, fp=sys.stdout)
    sys.exit(0 if results['ok'] is True else exit_error or 1)


# ##### -----------------------------------------------------------------------
# #####
# #####                           Main Code Functions
# #####
# ##### -----------------------------------------------------------------------

def do_push_config1(dev):
    topdir = g_cli_args.topdir
    config_dir = os.path.join(topdir, 'etc', 'configs', 'nxos')
    all_fpath = os.path.join(config_dir, 'all.conf')
    model_fpath = os.path.join(config_dir, dev.facts['hw_model'] + '.conf')
    changed = False

    try:
        if os.path.isfile(all_fpath):
            g_log.info('reading from: {}'.format(all_fpath))
            conf = open(all_fpath).read()
            g_log.info('pushing all config to device')
            dev.api.exec_config(conf)
            changed = True

        if os.path.isfile(model_fpath):
            g_log.info('reading model config from: {}'.format(model_fpath))
            conf = open(model_fpath).read()
            g_log.info('pushing model config to device')
            dev.api.exec_config(conf)
            changed = True

    except NxExc.NxosException as exc:
        g_log.critical("unable to push config: {}".format(exc.message))
        exit_results(dict(
            ok=False,
            error_type='config',
            message=exc.message))

    if changed is True:
        dev.api.exec_config("copy run start")


def check_os_install(dev):
    profile_dir = os.path.join(g_cli_args.topdir, 'etc', 'profiles', 'default', 'nxos')
    conf_fpath = os.path.join(profile_dir, 'os-selector.cfg')

    cmd = "aztp-os-selector -m {hw_model} -o '{os_ver}' -c {config}".format(
        hw_model=dev.facts['hw_model'],
        os_ver=dev.facts['os_version'],
        config=conf_fpath)

    child = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)

    _stdout, _stderr = child.communicate()
    return json.loads(_stdout)


def do_os_install(dev, image_name):

    image_fpath = os.path.join(g_cli_args.topdir,
                               'etc', 'image-catalog',
                               image_name)

    cmd = "nxos-installos --target {target} --server {server} "\
          "-U {u_env} -P {p_env} --image-profile {profile}"\
          .format(
            target=dev.target, server=g_cli_args.server,
            u_env=g_cli_args.user_var, p_env=g_cli_args.passwd_var,
            profile=image_fpath)

    if g_cli_args.logfile:
        cmd += ' --logfile %s' % g_cli_args.logfile

    child = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
    _stdout, _stderr = child.communicate()
    return json.loads(_stdout)


def do_ensure_os_version(dev):
    os_install = check_os_install(dev)

    if not os_install['image']:
        g_log.info('no software install required')
        return

    g_log.info('software image install required: %s' % os_install['image'])

    got = do_os_install(dev, image_name=os_install['image'])
    if not got['ok']:
        errmsg = 'software install [{ver}] FAILED: {reason}'.format(
                 ver=os_install['image'], reason=json.dumps(got))
        g_log.critical(errmsg)
        exit_results(dict(
            ok=False,
            error_type='install',
            message=errmsg))

    g_log.info('software install OK: %s' % json.dumps(got))
    g_log.info('rebooting device ... please be patient')

    time.sleep(g_cli_args.init_delay)
    return wait_for_device(countdown=g_cli_args.reload_delay, poll_delay=10)


def do_finalize(dev):
    profile_dir = os.path.join(g_cli_args.topdir, 'etc', 'profiles', 'default', 'nxos')

    finalizer = os.path.join(profile_dir, 'finally')
    if not os.path.isfile(finalizer):
        g_log.info('no user provided finally script')
        return

    cmd = '{prog}'.format(prog=finalizer)

    g_log.info("executing user provided finally script: {cmd}".format(cmd=cmd))

    child = subprocess.Popen(
        cmd, shell=True,
        stdout=subprocess.PIPE, stderr=subprocess.PIPE)

    _stdout, _stderr = child.communicate()
    g_log.info("finally stdout=[{}]".format(_stdout))
    g_log.info("finally stderr=[{}]".format(_stderr))


def wait_for_device(countdown, poll_delay):
    target = g_cli_args.target
    user = os.getenv(g_cli_args.user_var)
    passwd = os.getenv(g_cli_args.passwd_var)

    dev = None

    # first we need to wait for the device to be 'reachable' via the API.
    # we'll use the probe error to detect if it is or not

    while not dev:
        g_log.info('reload-countdown at: {} seconds'.format(countdown))

        try:
            dev = nxos.Device(
                target, user=user, passwd=passwd, timeout=poll_delay)

        except ProbeError:
            countdown -= poll_delay
            if countdown <= 0:
                exit_results(dict(
                    ok=False,
                    error_type='login',
                    message='Failed to probe target %s within reload countdown' % target))

        except UnauthorizedError:
            exit_results(dict(
                ok=False,
                error_type='login',
                message='Unauthorized - check user/password'))

    g_log.info('device reachable, waiting for System ready')
    while countdown >= 0:
        g_log.info('reload-countdown at: {} seconds'.format(countdown))
        try:
            dev.api.exec_opcmd('delete volatile:system_ready', msg_type='cli_show_ascii')
            return dev
        except NxExc.CommandError:
            # means that the file does not exist yet, so wait some time
            # and try again
            time.sleep(poll_delay)
            countdown -= poll_delay

    exit_results(dict(
        ok=False,
        error_type='login',
        message='%s failed to find "System ready" within reload countdown' % target))


def main():

    if not os.path.isdir(g_cli_args.topdir):
        exit_results(dict(
            ok=False,
            error_type='args',
            message='{} is not a directory'.format(g_cli_args.topdir)))

    g_log.info("starting bootstrap process in {} seconds"
               .format(g_cli_args.init_delay))

    # first wait the init_delay amount of time ... gives the device time
    # to start the shutdown process; i.e. expect this script to be kicked
    # off from the NXOS POAP process.

    time.sleep(g_cli_args.init_delay)

    dev = wait_for_device(countdown=g_cli_args.reload_delay, poll_delay=10)

    g_log.info("proceeding with bootstrap")

    do_push_config1(dev)
    dev = do_ensure_os_version(dev)
    do_finalize(dev)

    g_log.info("bootstrap process finished")
    exit_results(dict(ok=True))

if '__main__' == __name__:
    main()
